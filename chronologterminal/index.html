<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ChronoLog Terminal</title>

  <style>
    /* estilo básico do terminal (opcional) */
    html,{height:100%;margin:0;background:#0b0f11;color:#86ff9e;font:14px/1.4 ui-monospace,Menlo,Consolas,monospace}
    #terminal{max-width:960px;margin:24px auto;padding:16px}
    #status{color:#8fb4a0;margin-bottom:8px}
    #screen{min-height:320px;border:1px solid #183126;border-radius:10px;padding:12px;overflow:auto;background:#0d1417;box-shadow:inset 0 0 80px rgba(134,255,158,.05)}
    form#cmd{margin-top:10px;display:flex;gap:8px}
    #input{flex:1;background:#0f2a1a;color:#a8ffbf;border:1px solid #1c3d2a;border-radius:8px;padding:8px}
  </style>
<style>
  /* overlay de flash */
  .flash-overlay{
    position:fixed; inset:0; pointer-events:none; z-index:9999; opacity:0;
  }
  .flash-gold{ background: radial-gradient(60% 60% at 50% 50%, rgba(248,227,144,.35), rgba(248,227,144,0) 70%); }
  .flash-red { background: radial-gradient(60% 60% at 50% 50%, rgba(255,70,70,.25), rgba(255,70,70,0) 70%); }

  .flash-active{ animation: flashFade .6s ease-out; }
  @keyframes flashFade{ 0%{opacity:1} 100%{opacity:0} }
</style>

  <script>
    // ---------- FAVICON: anel animado (dourado) ----------
    function makeAnimatedRingDataURL(colorHex){
      const svg = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <style>
    circle { transform-box: fill-box; transform-origin: 50% 50%; }
    .ring-base {
      fill: none; stroke: ${colorHex}; stroke-width: 6; opacity: .9;
      filter: drop-shadow(0 0 6px ${colorHex}80);
    }
    .ring-glow {
      fill: none; stroke: ${colorHex}; stroke-width: 10; stroke-linecap: round;
      stroke-dasharray: 25 200;
      animation: spin 2s linear infinite, pulse 1.3s ease-in-out infinite;
      filter: drop-shadow(0 0 12px ${colorHex}); opacity: .9;
    }
    @keyframes spin { from {transform: rotate(0)} to {transform: rotate(360deg)} }
    @keyframes pulse { 0%,100% {opacity:.85} 50% {opacity:1} }
  </style>
  <circle class="ring-base" cx="50" cy="50" r="38"/>
  <circle class="ring-glow" cx="50" cy="50" r="38"/>
</svg>`;
      return "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(svg);
    }
    function setFaviconDataURL(dataUrl){
      document.querySelectorAll("link[rel*='icon']").forEach(el => el.remove());
      const link = document.createElement("link");
      link.rel = "icon";
      link.type = "image/svg+xml";
      link.href = dataUrl;
      document.head.appendChild(link);
    }
    document.addEventListener("DOMContentLoaded", ()=>{
      setFaviconDataURL( makeAnimatedRingDataURL("#f8e390") ); // dourado
    });
  </script>
</head>

<body>
  <div id="flash" class="flash-overlay"></div>

  <!-- SFX -->
  <audio id="sfxRumble" src="/assets/sfx/rumble.mp3" preload="auto"></audio>
  <audio id="sfxWhisper" src="/assets/sfx/whisper_rev.mp3" preload="auto"></audio>


  <div id="terminal">
    <div id="status">BOOTING…</div>
    <div id="screen"></div>
    <form id="cmd" autocomplete="off">
      <input id="input" type="text" placeholder="Type HELP" />
    </form>
  </div>

  <script>
    // ---------- ChronoLog Terminal JS ----------
    const LOGS_JSON = '/chronologterminal/logs.json';

    const screen   = document.getElementById('screen');
    const statusEl = document.getElementById('status');
    const form     = document.getElementById('cmd');
    const input    = document.getElementById('input');

    let logs = [];

    // helpers
    async function typeLine(text='', cls='', delay=12){
  const d = document.createElement('div');
  if(cls) d.className = cls;
  screen.appendChild(d);
  for(let i=0;i<text.length;i++){
    d.textContent += text[i];
    screen.scrollTop = screen.scrollHeight;
    await new Promise(r=>setTimeout(r, delay));
  }
}

    function flash(color='gold'){ 
  const el = document.getElementById('flash');
  if(!el) return;
  el.className = 'flash-overlay ' + (color==='red' ? 'flash-red' : 'flash-gold');
  // reflow p/ reiniciar animação
  void el.offsetWidth;
  el.classList.add('flash-active');
}

    const line = (t='', cls='') => {
      const d = document.createElement('div');
      d.textContent = t;
      if (cls) d.className = cls;
      screen.appendChild(d);
      screen.scrollTop = screen.scrollHeight;
    };
    const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

    async function decryptBuffer(buffer, password){
      const data = new Uint8Array(buffer);
      const salt = data.slice(0,16), iv = data.slice(16,28), tag = data.slice(data.length-16);
      const ciphertext = data.slice(28, data.length-16);
      const blob = new Uint8Array(ciphertext.length + tag.length);
      blob.set(ciphertext,0); blob.set(tag,ciphertext.length);
      const pw = new TextEncoder().encode(password);
      const keyMat = await crypto.subtle.importKey('raw', pw, 'PBKDF2', false, ['deriveKey']);
      const key = await crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations:150000, hash:'SHA-256'}, keyMat, {name:'AES-GCM', length:256}, false, ['decrypt']);
      return crypto.subtle.decrypt({name:'AES-GCM', iv}, key, blob.buffer);
    }

    async function boot(){
      statusEl.textContent = 'LINK_NEGOTIATING';
      line('[BOOT] INITIATING…'); await sleep(1000);
      line('[SCAN] VOID NETWORK…'); await sleep(1000);
      line('[AUTH] CHRONOLOG ACCESSED…'); await sleep(1000);
      statusEl.textContent = 'LINK_ESTABLISHED';
      line('[STATUS] LINK_ESTABLISHED');
      line('────────────────────────────────');
      line('VOID NETWORK ACCESS');
      line('Enter ACCESS CODE or type HELP');
      line('────────────────────────────────');
    }

    async function loadLogs(){
      try{
        const r = await fetch(LOGS_JSON,{cache:'no-store'});
        logs = await r.json();
      }catch{ /* silencioso */ }
    }
// === RATE LIMIT (LocalStorage) ===
const RATE_KEY = 'ch_rate_v1';
const MAX_ATTEMPTS = 6;                 // você queria 6
const WINDOW_MS   = 60*60*1000;         // 1h

function rl_get(){
  try { return JSON.parse(localStorage.getItem(RATE_KEY)) || {}; }
  catch { return {}; }
}
function rl_set(s){ localStorage.setItem(RATE_KEY, JSON.stringify(s)); }

const rateLimiter = {
  canAttempt(){
    const now = Date.now();
    const s = rl_get();
    if(!s.resetAt || now >= s.resetAt){
      rl_set({ count: 0, resetAt: now + WINDOW_MS });
      return true;
    }
    return (s.count || 0) < MAX_ATTEMPTS;
  },
  registerAttempt(){ // chamar SÓ quando falhar
    const now = Date.now();
    const s = rl_get();
    if(!s.resetAt || now >= s.resetAt){
      rl_set({ count: 1, resetAt: now + WINDOW_MS });
    } else {
      s.count = (s.count || 0) + 1;
      rl_set(s);
    }
  },
  attemptsLeft(){
    const s = rl_get();
    if(!s.resetAt || Date.now() >= s.resetAt) return MAX_ATTEMPTS;
    return Math.max(0, MAX_ATTEMPTS - (s.count || 0));
  },
  msLeft(){
    const s = rl_get();
    return (s.resetAt && Date.now() < s.resetAt) ? (s.resetAt - Date.now()) : 0;
  }
};

    function help(){
      line('AVAILABLE COMMANDS:');
      line('  HELP            – show this help');
      line('  LIST            – list transmissions (masked)');
      line('  ACCESS <CODE>   – open a record (ex: ACCESS TRANSMISSION #)');
    }

    function listMasked(){
      if(!logs.length){ line('No transmissions known.'); return; }
      line('KNOWN TRANSMISSIONS (MASKED):');
      logs.forEach(l=> line(`  • ${l.id} — ${l.title.replace(/[A-Za-z0-9]/g,'█')}`));
    }

    async function openByCode(code){
      const normalized = code.trim().toUpperCase();
      let match = logs.find(l=> l.id.toUpperCase() === normalized);
      if(!match){
        match = logs.find(l=>{
          const bag = [l.id, l.title, l.file].join(' ').toUpperCase();
          return bag.includes(normalized);
        });
      }
      if(!match){ line('ACCESS: DENIED'); return; }

      try{
        const txt = await fetch(match.file,{cache:'no-store'}).then(r=>r.text());
        line('────────────────────────────────');
        line(`[OPEN] LOG ${match.id}`);
        line(txt);
        line('────────────────────────────────');
      }catch{
        line('ERROR: Failed to recover record.');
      }
// === RATE LIMIT (LocalStorage) ===
const RATE_KEY = 'ch_rate_v1';        // mude se quiser resetar geral
const MAX_ATTEMPTS = 5;               // tentativas por janela
const WINDOW_MS = 60 * 60 * 1000;     // 1 hora

function rl_get(){
  try { return JSON.parse(localStorage.getItem(RATE_KEY)) || {}; }
  catch { return {}; }
}
function rl_set(s){ localStorage.setItem(RATE_KEY, JSON.stringify(s)); }

const rateLimiter = {
  canAttempt(){
    const now = Date.now();
    const s = rl_get();
    if (!s.resetAt || now >= s.resetAt){
      // abre nova janela
      rl_set({ count: 0, resetAt: now + WINDOW_MS });
      return true;
    }
    return (s.count || 0) < MAX_ATTEMPTS;
  },
  registerAttempt(){
    const now = Date.now();
    const s = rl_get();
    if (!s.resetAt || now >= s.resetAt){
      rl_set({ count: 1, resetAt: now + WINDOW_MS });
    } else {
      s.count = (s.count || 0) + 1;
      rl_set(s);
    }
  },
  attemptsLeft(){
    const now = Date.now();
    const s = rl_get();
    if (!s.resetAt || now >= s.resetAt) return MAX_ATTEMPTS;
    return Math.max(0, MAX_ATTEMPTS - (s.count || 0));
  },
  msLeft(){
    const now = Date.now();
    const s = rl_get();
    return (s.resetAt && now < s.resetAt) ? (s.resetAt - now) : 0;
  },
  reset(){ localStorage.removeItem(RATE_KEY); } // útil pra testes
};

      if(match.encFile){
        line('ATTACHMENT: ENCRYPTED — type PASS <password> to unlock & download');
        form.dataset.pendingEnc = match.encFile;
        form.dataset.attachName = match.attachName || 'attachment.bin';
        form.dataset.mime = match.mime || 'application/octet-stream';
      }else{
        delete form.dataset.pendingEnc;
      }
    }

    async function tryPassword(pw){
      const enc = form.dataset.pendingEnc;
      if(!enc){ line('No pending encrypted attachment.'); return; }
      line('[DECRYPT] downloading…');
      try{
        const buf = await fetch(enc,{cache:'no-store'}).then(r=>r.arrayBuffer());
        const dec = await decryptBuffer(buf, pw);
        const blob = new Blob([dec], {type: form.dataset.mime});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=form.dataset.attachName; a.click();
        line('[DECRYPT] success — file saved.');
        delete form.dataset.pendingEnc;
      }catch{
        line('[DECRYPT] failed — wrong password or corrupt file.');
      }
    }

      // efeito
flash('red');
playSFX('sfxRumble');
playSFX('sfxWhisper');
setStatus('TRACE_RISK: ELEVATED');

      // mensagem ritual
if (attemptsData.lockUntil && Date.now() < attemptsData.lockUntil) {
  line("ACCESS LOCKED");
await typeLine("You're calling too much attention.");
await typeLine("The Void is aware.");
await typeLine("Come back later.");
    return;
}
// após tentar ACCESS / PASS / openByCode:
async function openByCode(code){
  const normalized = code.trim().toUpperCase();
  let match = logs.find(l=> l.id.toUpperCase() === normalized);
  if(!match){
    match = logs.find(l=>{
      const bag = [l.id, l.title, l.file].join(' ').toUpperCase();
      return bag.includes(normalized);
    });
  }
  if(!match){
    line('ACCESS: DENIED');
    return false;                // <— FALHA
  }

  try{
    const txt = await fetch(match.file,{cache:'no-store'}).then(r=>r.text());
    line('────────────────────────────────');
    line(`[OPEN] LOG ${match.id}`);
    line(txt);
    line('────────────────────────────────');
  }catch{
    line('ERROR: Failed to recover record.');
    return false;                // <— FALHA
  }

  if(match.encFile){
    line('ATTACHMENT: ENCRYPTED — type PASS <password> to unlock & download');
    form.dataset.pendingEnc = match.encFile;
    form.dataset.attachName = match.attachName || 'attachment.bin';
    form.dataset.mime = match.mime || 'application/octet-stream';
  } else {
    delete form.dataset.pendingEnc;
  }
  return true;                   // <— SUCESSO
}


flash('red');
playSFX('sfxRumble');
setStatus('TRACE_RISK: HIGH');

await typeLine('[TRACE WARNING]');
await typeLine('You’ve stayed in the Void Network for too long.');
await typeLine('The signal is starting to echo back.');
line('');
await typeLine('Disconnect now.');
await typeLine('Return after the field settles.');
          
  rateLimiter.registerAttempt(); // conta a tentativa (sucesso ou erro)
  await openByCode(arg);
  break;

        case 'PASS':
          if(!arg){ line('USAGE: PASS <password>'); break; }
          await tryPassword(arg); break;
        default:
          await openByCode(cmd + (arg ? (' ' + arg) : ''));
      }
    });

    (async function(){
      await loadLogs();
      await boot();
      input.focus();
 form.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const value = input.value.trim();
  if(!value) return;
  line('> ' + value);
  input.value='';

  const [cmd, ...rest] = value.split(' ');
  const arg = rest.join(' ').trim();

  switch(cmd.toUpperCase()){
    case 'HELP':  help(); break;
    case 'LIST':  listMasked(); break;

    case 'ACCESS':
      if(!arg){ line('USAGE: ACCESS <CODE>'); break; }

      // Checa bloqueio
      if(!rateLimiter.canAttempt()){
        const mins = Math.max(1, Math.ceil(rateLimiter.msLeft()/60000));
        flash('red');
        playSFX('sfxRumble');
        setStatus('TRACE_RISK: HIGH');

        await typeLine('[TRACE WARNING]');
        await typeLine('You’ve stayed in the Void Network for too long.');
        await typeLine('The signal is starting to echo back.');
        line('');
        await typeLine(`Disconnect now. Return in ~${mins} minutes.`);
        break;
      }

      // Tenta abrir
      const ok = await openByCode(arg);

      // Se falhou, conta tentativa e, se zerou, mostra a mensagem “ritual”
      if(!ok){
        rateLimiter.registerAttempt();
        if(!rateLimiter.canAttempt()){
          flash('gold');
          playSFX('sfxRumble');
          playSFX('sfxWhisper');
          setStatus('TRACE_RISK: ELEVATED');

          await typeLine('[ACCESS LOCKED]');
          await typeLine("You're calling too much attention.");
          await typeLine('The Void is aware of your presence now.');
          line('');
          await typeLine('Wait before you try again.');
          await typeLine('Return only when you are certain of the code.');
        }
      }
      break;

    case 'PASS':
      if(!arg){ line('USAGE: PASS <password>'); break; }
      await tryPassword(arg);
      break;

    default:
      // fallback: tenta abrir direto o que foi digitado
      await openByCode(cmd + (arg ? (' ' + arg) : ''));
  }
});

  </script>
</>
</html>
