<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ChronoLog Terminal</title>

  <style>
    /* estilo básico do terminal */
    html, body { height:100%; margin:0; background:#0b0f11; color:#86ff9e; font:14px/1.4 ui-monospace,Menlo,Consolas,monospace; }
    #terminal{ max-width:960px; margin:24px auto; padding:16px; }
    #status{ color:#8fb4a0; margin-bottom:8px; }
    #screen{ min-height:320px; border:1px solid #183126; border-radius:10px; padding:12px; overflow:auto; background:#0d1417; box-shadow:inset 0 0 80px rgba(134,255,158,.05); }
    form#cmd{ margin-top:10px; display:flex; gap:8px; }
    #input{ flex:1; background:#0f2a1a; color:#a8ffbf; border:1px solid #1c3d2a; border-radius:8px; padding:8px; }

    /* overlay de flash */
    .flash-overlay{ position:fixed; inset:0; pointer-events:none; z-index:9999; opacity:0; }
    .flash-gold{ background: radial-gradient(60% 60% at 50% 50%, rgba(248,227,144,.35), rgba(248,227,144,0) 70%); }
    .flash-red { background: radial-gradient(60% 60% at 50% 50%, rgba(255,70,70,.25), rgba(255,70,70,0) 70%); }
    .flash-active{ animation: flashFade .6s ease-out; }
    @keyframes flashFade{ 0%{opacity:1} 100%{opacity:0} }
  </style>

  <script>
    // ---------- FAVICON: anel animado (dourado) ----------
    function makeAnimatedRingDataURL(colorHex){
      const svg = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <style>
    circle { transform-box: fill-box; transform-origin: 50% 50%; }
    .ring-base {
      fill: none; stroke: ${colorHex}; stroke-width: 6; opacity: .9;
      filter: drop-shadow(0 0 6px ${colorHex}80);
    }
    .ring-glow {
      fill: none; stroke: ${colorHex}; stroke-width: 10; stroke-linecap: round;
      stroke-dasharray: 25 200;
      animation: spin 2s linear infinite, pulse 1.3s ease-in-out infinite;
      filter: drop-shadow(0 0 12px ${colorHex}); opacity: .9;
    }
    @keyframes spin { from {transform: rotate(0)} to {transform: rotate(360deg)} }
    @keyframes pulse { 0%,100% {opacity:.85} 50% {opacity:1} }
  </style>
  <circle class="ring-base" cx="50" cy="50" r="38"/>
  <circle class="ring-glow" cx="50" cy="50" r="38"/>
</svg>`;
      return "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(svg);
    }
    function setFaviconDataURL(dataUrl){
      document.querySelectorAll("link[rel*='icon']").forEach(el => el.remove());
      const link = document.createElement("link");
      link.rel = "icon";
      link.type = "image/svg+xml";
      link.href = dataUrl;
      document.head.appendChild(link);
    }
    document.addEventListener("DOMContentLoaded", ()=>{
      setFaviconDataURL( makeAnimatedRingDataURL("#f8e390") ); // dourado para o ChronoLog
    });
  </script>
</head>

<body>
  <div id="flash" class="flash-overlay"></div>

  <!-- SFX -->
  <audio id="sfxRumble" src="/assets/sfx/rumble.mp3" preload="auto"></audio>
  <audio id="sfxWhisper" src="/assets/sfx/whisper_rev.mp3" preload="auto"></audio>

  <div id="terminal">
    <div id="status">BOOTING…</div>
    <div id="screen"></div>
    <form id="cmd" autocomplete="off">
      <input id="input" type="text" placeholder="Type HELP" />
    </form>
  </div>

  <script>
    // ---------- ChronoLog Terminal JS ----------
    const LOGS_JSON = '/chronologterminal/logs.json';

    const screen   = document.getElementById('screen');
    const statusEl = document.getElementById('status');
    const form     = document.getElementById('cmd');
    const input    = document.getElementById('input');

    let logs = [];

    // helpers visuais/áudio
    const line = (t='', cls='') => {
      const d = document.createElement('div');
      d.textContent = t;
      if (cls) d.className = cls;
      screen.appendChild(d);
      screen.scrollTop = screen.scrollHeight;
    };
    const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

    async function typeLine(text='', cls='', delay=12){
      const d = document.createElement('div');
      if(cls) d.className = cls;
      screen.appendChild(d);
      for(let i=0;i<text.length;i++){
        d.textContent += text[i];
        screen.scrollTop = screen.scrollHeight;
        await new Promise(r=>setTimeout(r, delay));
      }
    }

    function flash(color='gold'){ 
      const el = document.getElementById('flash');
      if(!el) return;
      el.className = 'flash-overlay ' + (color==='red' ? 'flash-red' : 'flash-gold');
      void el.offsetWidth; // reflow p/ reiniciar animação
      el.classList.add('flash-active');
    }

    function setStatus(s){ if(statusEl) statusEl.textContent = s; }

    function playSFX(id, vol=0.35){
      const el = document.getElementById(id);
      if(!el) return;
      el.currentTime = 0;
      el.volume = vol;
      el.play().catch(()=>{});
    }

    // desbloqueio de áudio após 1ª interação (autoplay policy)
    let audioUnlocked = false;
    function unlockAudioOnce(){
      if(audioUnlocked) return;
      ['sfxRumble','sfxWhisper'].forEach(id=>{
        const el = document.getElementById(id);
        if(!el) return;
        el.volume = .001;
        el.play().then(()=>{ el.pause(); el.currentTime=0; audioUnlocked = true; }).catch(()=>{});
      });
    }
    document.addEventListener('click', unlockAudioOnce, {once:true});
    document.addEventListener('keydown', unlockAudioOnce, {once:true});

    // crypto helper
    async function decryptBuffer(buffer, password){
      const data = new Uint8Array(buffer);
      const salt = data.slice(0,16), iv = data.slice(16,28), tag = data.slice(data.length-16);
      const ciphertext = data.slice(28, data.length-16);
      const blob = new Uint8Array(ciphertext.length + tag.length);
      blob.set(ciphertext,0); blob.set(tag,ciphertext.length);
      const pw = new TextEncoder().encode(password);
      const keyMat = await crypto.subtle.importKey('raw', pw, 'PBKDF2', false, ['deriveKey']);
      const key = await crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations:150000, hash:'SHA-256'}, keyMat, {name:'AES-GCM', length:256}, false, ['decrypt']);
      return crypto.subtle.decrypt({name:'AES-GCM', iv}, key, blob.buffer);
    }

    // boot + dados
    async function boot(){
      statusEl.textContent = 'LINK_NEGOTIATING';
      line('[BOOT] INITIATING…'); await sleep(1000);
      line('[SCAN] VOID NETWORK…'); await sleep(1000);
      line('[AUTH] CHRONOLOG ACCESSED…'); await sleep(1000);
      statusEl.textContent = 'LINK_ESTABLISHED';
      line('[STATUS] LINK_ESTABLISHED');
      line('────────────────────────────────');
      line('VOID NETWORK ACCESS');
      line('Enter ACCESS CODE or type HELP');
      line('────────────────────────────────');
    }

    async function loadLogs(){
      try{
        const r = await fetch(LOGS_JSON,{cache:'no-store'});
        logs = await r.json();
      }catch{/* silencioso */}
    }

    // === RATE LIMIT (LocalStorage) ===
    const RATE_KEY   = 'ch_rate_v1';
    const MAX_ATTEMPTS = 6;                 // 6 tentativas
    const WINDOW_MS    = 60*60*1000;        // janela de 1h

    function rl_get(){
      try { return JSON.parse(localStorage.getItem(RATE_KEY)) || {}; }
      catch { return {}; }
    }
    function rl_set(s){ localStorage.setItem(RATE_KEY, JSON.stringify(s)); }

    const rateLimiter = {
      canAttempt(){
        const now = Date.now();
        const s = rl_get();
        if(!s.resetAt || now >= s.resetAt){
          rl_set({ count: 0, resetAt: now + WINDOW_MS });
          return true;
        }
        return (s.count || 0) < MAX_ATTEMPTS;
      },
      registerAttempt(){ // chamar SÓ quando falhar
        const now = Date.now();
        const s = rl_get();
        if(!s.resetAt || now >= s.resetAt){
          rl_set({ count: 1, resetAt: now + WINDOW_MS });
        } else {
          s.count = (s.count || 0) + 1;
          rl_set(s);
        }
      },
      attemptsLeft(){
        const s = rl_get();
        if(!s.resetAt || Date.now() >= s.resetAt) return MAX_ATTEMPTS;
        return Math.max(0, MAX_ATTEMPTS - (s.count || 0));
      },
      msLeft(){
        const s = rl_get();
        return (s.resetAt && Date.now() < s.resetAt) ? (s.resetAt - Date.now()) : 0;
      }
    };

    // UI helpers
    function help(){
      line('AVAILABLE COMMANDS:');
      line('  HELP            – show this help');
      line('  LIST            – list transmissions (masked)');
      line('  ACCESS <CODE>   – open a record (ex: ACCESS 963)');
    }

    function listMasked(){
      if(!logs.length){ line('No transmissions known.'); return; }
      line('KNOWN TRANSMISSIONS (MASKED):');
      logs.forEach(l=> line(`  • ${l.id} — ${l.title.replace(/[A-Za-z0-9]/g,'█')}`));
    }

    // abre log por código (retorna boolean sucesso/falha)
    async function openByCode(code){
      const normalized = code.trim().toUpperCase();
      let match = logs.find(l=> l.id.toUpperCase() === normalized);
      if(!match){
        match = logs.find(l=>{
          const bag = [l.id, l.title, l.file].join(' ').toUpperCase();
          return bag.includes(normalized);
        });
      }
      if(!match){
        line('ACCESS: DENIED');
        return false; // falha
      }

      try{
        const txt = await fetch(match.file,{cache:'no-store'}).then(r=>r.text());
        line('────────────────────────────────');
        line(`[OPEN] LOG ${match.id}`);
        line(txt);
        line('────────────────────────────────');
      }catch{
        line('ERROR: Failed to recover record.');
        return false; // falha
      }

      if(match.encFile){
        line('ATTACHMENT: ENCRYPTED — type PASS <password> to unlock & download');
        form.dataset.pendingEnc  = match.encFile;
        form.dataset.attachName  = match.attachName || 'attachment.bin';
        form.dataset.mime        = match.mime || 'application/octet-stream';
      } else {
        delete form.dataset.pendingEnc;
      }
      return true; // sucesso
    }

    async function tryPassword(pw){
      const enc = form.dataset.pendingEnc;
      if(!enc){ line('No pending encrypted attachment.'); return; }
      line('[DECRYPT] downloading…');
      try{
        const buf = await fetch(enc,{cache:'no-store'}).then(r=>r.arrayBuffer());
        const dec = await decryptBuffer(buf, pw);
        const blob = new Blob([dec], {type: form.dataset.mime});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=form.dataset.attachName; a.click();
        line('[DECRYPT] success — file saved.');
        delete form.dataset.pendingEnc;
      }catch{
        line('[DECRYPT] failed — wrong password or corrupt file.');
      }
    }

    // SUBMIT
    form.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const value = input.value.trim();
      if(!value) return;
      line('> ' + value);
      input.value='';

      const [cmd, ...rest] = value.split(' ');
      const arg = rest.join(' ').trim();

      switch(cmd.toUpperCase()){
        case 'HELP':  help(); break;
        case 'LIST':  listMasked(); break;

        case 'ACCESS':
          if(!arg){ line('USAGE: ACCESS <CODE>'); break; }

          // bloqueio
          if(!rateLimiter.canAttempt()){
            const mins = Math.max(1, Math.ceil(rateLimiter.msLeft()/60000));
            flash('red');
            playSFX('sfxRumble');
            setStatus('TRACE_RISK: HIGH');

            await typeLine('[TRACE WARNING]');
            await typeLine('You’ve stayed in the Void Network for too long.');
            await typeLine('The signal is starting to echo back.');
            line('');
            await typeLine(`Disconnect now. Return in ~${mins} minutes.`);
            break;
          }

          // tentativa
          const ok = await openByCode(arg);

          // falhou? conta e talvez fecha a janela
          if(!ok){
            rateLimiter.registerAttempt();
            if(!rateLimiter.canAttempt()){
              flash('gold');
              playSFX('sfxRumble');
              playSFX('sfxWhisper');
              setStatus('TRACE_RISK: ELEVATED');

              await typeLine('[ACCESS LOCKED]');
              await typeLine("You're calling too much attention.");
              await typeLine('The Void is aware of your presence now.');
              line('');
              await typeLine('Wait before you try again.');
              await typeLine('Return only when you are certain of the code.');
            }
          }
          break;

        case 'PASS':
          if(!arg){ line('USAGE: PASS <password>'); break; }
          await tryPassword(arg);
          break;

        default:
          // fallback: tenta abrir direto
          await openByCode(cmd + (arg ? (' ' + arg) : ''));
      }
    });

    (async function(){
      await loadLogs();
      await boot();
      input.focus();
    })();
  </script>
</body>
</html>
