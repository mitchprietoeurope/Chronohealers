<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ChronoLog Terminal</title>
  <!-- Favicon default (será sobrescrito pelo script) -->
<link rel="icon" type="image/svg+xml" href="/assets/favicon-green.svg">
<link rel="alternate icon" type="image/png" href="/assets/favicon-green.png">
  <style>
    :root{--bg:#010204;--accent:#86ff9e;--muted:#8fb4a0}
    html,body{height:100%;margin:0;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace;background:linear-gradient(180deg,#050708,#020204);color:var(--accent)}
    .container{padding:28px;max-width:980px;margin:32px auto}
    .header{display:flex;align-items:center;justify-content:space-between}
    .h1{font-size:18px}
    .list{margin-top:18px}
    .log{background:#061014;padding:14px;border-radius:8px;margin-bottom:10px}
    .log h3{margin:0 0 8px}
    .btn{background:transparent;border:1px solid rgba(134,255,158,.18);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer}
    .input{padding:8px;border-radius:6px;border:1px solid rgba(134,255,158,.06);background:#021014;color:var(--accent)}
    .output{white-space:pre-wrap;background:#000;padding:14px;border-radius:8px;margin-top:12px;color:#bfffd6}
    .small{font-size:12px;color:#8fb4a0}
  </style>
</head>
<body>
 <div class="container">
  <div class="header">
    <div class="h1">CHRONOLOG TERMINAL • Layer Zero</div>
    <div class="small">Status: <span id="status">LINK_NEGOTIATING</span></div>
  </div>

  <div id="screen" class="output" aria-live="polite"></div>

  <form id="cmd" style="margin-top:10px; display:flex; gap:8px">
    <input id="input" class="input" placeholder="ENTER ACCESS CODE (or type HELP)" autocomplete="off">
    <button class="btn" type="submit">RUN</button>
  </form>
</div>


 <script>
  const LOGS_JSON = '/chronologterminal/logs.json';
  const screen = document.getElementById('screen');
  const statusEl = document.getElementById('status');
  const form = document.getElementById('cmd');
  const input = document.getElementById('input');

  let logs = [];

  // print helpers
  const line = (t='', cls='') => {
    const d = document.createElement('div');
    d.textContent = t; if(cls) d.className = cls;
    screen.appendChild(d); screen.scrollTop = screen.scrollHeight;
  };
  const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

  // decrypt helper (mesmo do teu)
  async function decryptBuffer(buffer, password){
    const data = new Uint8Array(buffer);
    const salt = data.slice(0,16), iv = data.slice(16,28), tag = data.slice(data.length-16);
    const ciphertext = data.slice(28, data.length-16);
    const blob = new Uint8Array(ciphertext.length + tag.length);
    blob.set(ciphertext,0); blob.set(tag,ciphertext.length);
    const pw = new TextEncoder().encode(password);
    const keyMat = await crypto.subtle.importKey('raw', pw, 'PBKDF2', false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations:150000, hash:'SHA-256'}, keyMat, {name:'AES-GCM', length:256}, false, ['decrypt']);
    return crypto.subtle.decrypt({name:'AES-GCM', iv}, key, blob.buffer);
  }

  async function boot(){
    statusEl.textContent = 'LINK_NEGOTIATING';
    line('[BOOT] INIT…'); await sleep(300);
    line('[SCAN] VOID NETWORK…'); await sleep(300);
    line('[AUTH] HANDSHAKE L0…'); await sleep(300);
    statusEl.textContent = 'LINK_ESTABLISHED';
    line('[STATUS] LINK_ESTABLISHED');
    line('────────────────────────────────');
    line('VOID NETWORK ACCESS');
    line('Enter ACCESS CODE or type HELP');
    line('────────────────────────────────');
  }

  async function loadLogs(){
    try{
      const r = await fetch(LOGS_JSON,{cache:'no-store'});
      logs = await r.json();
    }catch{
      // silencioso: sem listar nada
    }
  }

  function help(){
    line('AVAILABLE COMMANDS:');
    line('  HELP            – show this help');
    line('  LIST            – list transmissions (masked)');
    line("  ACCESS <CODE>   – open a record (ex: ACCESS 963 or ACCESS LOG_ΔTW03)");
  }

  function listMasked(){
    if(!logs.length){ line('No transmissions known.'); return; }
    line('KNOWN TRANSMISSIONS (MASKED):');
    logs.forEach(l=> line(`  • ${l.id} — ${l.title.replace(/[A-Za-z0-9]/g,'█')}`));
  }

  async function openByCode(code){
    const normalized = code.trim().toUpperCase();
    // match por id numérico (963) ou presença do id no title/arquivo
    let match = logs.find(l=> l.id.toUpperCase()===normalized);
    if(!match){
      // tentativa básica: se digitar LOG_ΔTW03 ou 964, mapeia
      match = logs.find(l=>{
        const bag = [l.id, l.title, l.file].join(' ').toUpperCase();
        return bag.includes(normalized);
      });
    }
    if(!match){ line('ACCESS: DENIED'); return; }

    // carrega o texto
    try{
      const txt = await fetch(match.file,{cache:'no-store'}).then(r=>r.text());
      line('────────────────────────────────'); 
      line(`[OPEN] LOG ${match.id}`);
      line(txt); 
      line('────────────────────────────────'); 
    }catch{
      line('ERROR: Failed to recover record.');
    }

    // anexo opcional
    if(match.encFile){
      line('ATTACHMENT: ENCRYPTED — type PASS <password> to unlock & download');
      // armazena no form uma “sessão” simples
      form.dataset.pendingEnc = match.encFile;
      form.dataset.attachName = match.attachName || 'attachment.bin';
      form.dataset.mime = match.mime || 'application/octet-stream';
    } else {
      delete form.dataset.pendingEnc;
    }
  }

  async function tryPassword(pw){
    const enc = form.dataset.pendingEnc;
    if(!enc){ line('No pending encrypted attachment.'); return; }
    line('[DECRYPT] downloading…');
    try{
      const buf = await fetch(enc,{cache:'no-store'}).then(r=>r.arrayBuffer());
      const dec = await decryptBuffer(buf, pw);
      const blob = new Blob([dec], {type: form.dataset.mime});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download=form.dataset.attachName; a.click();
      line('[DECRYPT] success — file saved.');
      delete form.dataset.pendingEnc;
    }catch{
      line('[DECRYPT] failed — wrong password or corrupt file.');
    }
  }

  form.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const value = input.value.trim();
    if(!value) return;
    line('> ' + value);
    input.value='';

    const [cmd, ...rest] = value.split(' ');
    const arg = rest.join(' ').trim();

    switch(cmd.toUpperCase()){
      case 'HELP': help(); break;
      case 'LIST': listMasked(); break;
      case 'ACCESS':
        if(!arg){ line('USAGE: ACCESS <CODE>'); break; }
        await openByCode(arg); break;
      case 'PASS':
        if(!arg){ line('USAGE: PASS <password>'); break; }
        await tryPassword(arg); break;
      default:
        // tentativa direta: se o usuário só digitar 963 ou LOG_ΔTW03
        await openByCode(cmd + (arg?' '+arg:''));
    }
  });

  (async function(){
    await loadLogs();
    await boot();
    input.focus();
  })();
</script>
<script>
  function setFavicon(svgPath, pngPath){
    // remove favicons existentes
    document.querySelectorAll("link[rel*='icon']").forEach(el => el.remove());
    // adiciona SVG
    const svg = document.createElement("link");
    svg.rel  = "icon";
    svg.type = "image/svg+xml";
    svg.href = svgPath;
    document.head.appendChild(svg);
    // fallback PNG (opcional)
    if (pngPath){
      const png = document.createElement("link");
      png.rel  = "alternate icon";
      png.type = "image/png";
      png.href = pngPath;
      document.head.appendChild(png);
    }
  }

  function applyFaviconByPath(){
    const path = location.pathname.toLowerCase();
    const isTerminal = path.startsWith("/chronologterminal");
    if (isTerminal){
      // ChronoLog = dourado
      setFavicon("/assets/favicon.svg", "/assets/favicon-gold.png");
    } else {
      // Home e demais = verde
      setFavicon("/assets/favicon-green.svg", "/assets/favicon-green.png");
    }
  }

  // aplica ao carregar
  document.addEventListener("DOMContentLoaded", applyFaviconByPath);
  // re-aplica se mudar de histórico (caso haja navegação interna)
  window.addEventListener("popstate", applyFaviconByPath);
  // e quando a aba volta a ficar visível (garante pós-cache)
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") applyFaviconByPath();
  });
</script>
</body>
</html>
